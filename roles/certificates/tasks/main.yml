---

- name: Create certs directory
  file:
    path: "{{ certs_dir }}"
    state: directory
    mode: '0755'
  when: inventory_hostname == "vm1"

- name: Generate CA for Elasticsearch
  command: >
    /usr/share/elasticsearch/bin/elasticsearch-certutil ca
    --silent
    --out {{ certs_dir }}/{{ ca_file }}
    --pass ""
  args:
    creates: "{{ certs_dir }}/{{ ca_file }}"
  when: inventory_hostname == "vm1"

- name: Generate node certificate and private key on VM1 (auto-enter) and set permissions
  shell: |
    printf '\n\n' | /usr/share/elasticsearch/bin/elasticsearch-certutil cert \
      --ca {{ certs_dir }}/{{ ca_file }} \
      --out {{ certs_dir }}/{{ cert_file }}
    chmod 0644 {{ certs_dir }}/{{ cert_file }}
  args:
    creates: "{{ certs_dir }}/{{ cert_file }}"
  become: yes
  when: inventory_hostname == "vm1"
  vars:
    certs_dir: /tmp/es_certs
    ca_file: elastic-stack-ca.p12

- name: Set permissions on CA and node certificate files to 0644
  file:
    path: "{{ item }}"
    mode: '0644'
  loop:
    - "{{ certs_dir }}/{{ ca_file }}"
    - "{{ certs_dir }}/{{ cert_file }}"
  when: inventory_hostname == "vm1"


- name: Fetch CA file from VM1 to Ansible controller
  fetch:
    src: "{{ certs_dir }}/{{ cert_file }}"
    dest: "{{ playbook_dir }}/certs/{{ cert_file }}"
    flat: yes
  when: inventory_hostname == "vm1"

- name: Copy CA file from controller to /etc/elasticsearch on all nodes
  copy:
    src: "{{ playbook_dir }}/certs/{{ cert_file }}"
    dest: "/etc/elasticsearch/{{ cert_file }}"
    owner: root
    group: root
    mode: '0644'
  become: yes

- name: Check if keystore/truststore passwords are already empty
  shell: "/usr/share/elasticsearch/bin/elasticsearch-keystore show {{ item }}"
  register: keystore_check
  failed_when: false
  changed_when: false
  become: yes
  loop:
    - xpack.security.transport.ssl.keystore.secure_password
    - xpack.security.transport.ssl.truststore.secure_password
  loop_control:
    label: "{{ item }}"

- name: Set empty password if needed (keystore or truststore)
  shell: "printf 'y\n\n' | /usr/share/elasticsearch/bin/elasticsearch-keystore add {{ item.item }}"
  become: yes
  when: item.stdout != ""
  loop: "{{ keystore_check.results }}"
  loop_control:
    label: "{{ item.item }}"


- name: Configure elasticsearch.yml
  template:
    src: elasticsearch.yml.j2
    dest: /etc/elasticsearch/elasticsearch.yml
    owner: root
    group: elasticsearch
    mode: '0640'


# === Service Management ===
- name: Enable and start Elasticsearch
  systemd:
    name: elasticsearch
    enabled: true
    state: restarted
    daemon_reload: yes


- name: Set xpack.security.enabled to true in Elasticsearch configuration
  replace:
    path: /etc/elasticsearch/elasticsearch.yml
    regexp: '^xpack\.security\.enabled:\s*false'
    replace: 'xpack.security.enabled: true'
  become: yes

- name: Set xpack.security.authc.api_key.enabled to true in Elasticsearch configuration
  replace:
    path: /etc/elasticsearch/elasticsearch.yml
    regexp: '^xpack\.security\.authc\.api_key\.enabled:\s*false'
    replace: 'xpack.security.authc.api_key.enabled: true'
  become: yes


- name: Enable and start Elasticsearch
  systemd:
    name: elasticsearch
    enabled: true
    state: restarted
    daemon_reload: yes

- name: Reset elastic user password interactively
  shell: |
    printf 'y\n{{ elastic_password }}\n{{ elastic_password }}\n' | \
    /usr/share/elasticsearch/bin/elasticsearch-reset-password -i -u elastic
  become: yes


- name: Reset kibana_system user password interactively
  shell: |
    printf 'y\n{{ kibana_system_password }}\n{{ kibana_system_password }}\n' | \
    /usr/share/elasticsearch/bin/elasticsearch-reset-password -i -u kibana_system
  become: yes

- name: Stop Elasticsearch service
  ansible.builtin.service:
    name: elasticsearch
    state: stopped
  become: yes
  ignore_errors: yes

- name: Stop Kibana service (only on Kibana nodes)
  ansible.builtin.service:
    name: kibana
    state: stopped
  become: yes
  ignore_errors: yes
  when: "'kibana' in group_names"

# - name: Generate Elasticsearch HTTP certificates on VM1
#   ansible.builtin.command: >
#     /usr/share/elasticsearch/bin/elasticsearch-certutil http
#     --ca {{ certs_dir }}/elastic-stack-ca.p12
#     --ca-pass ""
#     --out {{ certs_dir }}/elasticsearch-ssl-http.zip
#   args:
#     chdir: /usr/share/elasticsearchenerate Elasticsearch HTTP certificates on VM1
#     creates: "{{ certs_dir }}/elasticsearch-ssl-http.zip"
#   become: yes
#   when: inventory_hostname == 'vm1'

- name: Generate HTTP certs script from template
  template:
    src: gen_http_certs.sh.j2
    dest: /tmp/gen_http_certs.sh
    mode: '0755'
  when: inventory_hostname == 'vm1'

# Check if HTTP certs already exist
- name: Check if elasticsearch-ssl-http.zip exists
  stat:
    path: /usr/share/elasticsearch/elasticsearch-ssl-http.zip
  register: http_certs_file
  when: inventory_hostname == 'vm1'

# Run the HTTP certs generation script only if certs do not exist
- name: Run the HTTP certs generation script
  shell: /tmp/gen_http_certs.sh
  args:
    chdir: /tmp
  when: inventory_hostname == 'vm1' and not http_certs_file.stat.exists


# 1. On VM1, copy /usr/share/elasticsearch/elasticsearch-ssl-http.zip to /tmp
- name: Copy elasticsearch-ssl-http.zip to /tmp on VM1
  copy:
    src: /usr/share/elasticsearch/elasticsearch-ssl-http.zip
    dest: /tmp/elasticsearch-ssl-http.zip
    remote_src: true
    mode: '0644'
  when: inventory_hostname == 'vm1'

# 1. Ensure tmp folder exists on control node
- name: Ensure tmp folder exists on control node
  delegate_to: localhost
  run_once: true
  file:
    path: "{{ playbook_dir }}/tmp"
    state: directory
    mode: '0755'
    owner: "{{ lookup('env', 'USER') }}"
    group: "{{ lookup('env', 'USER') }}"

# 2. Fetch elasticsearch-ssl-http.zip from VM1 to control node
- name: Fetch elasticsearch-ssl-http.zip from VM1 to control node
  fetch:
    src: /tmp/elasticsearch-ssl-http.zip
    dest: "{{ playbook_dir }}/tmp/elasticsearch-ssl-http.zip"
    flat: true
  become: true
  when: inventory_hostname == 'vm1'


# 4. Copy elasticsearch-ssl-http.zip from control node to VM2 /tmp directory
- name: Copy elasticsearch-ssl-http.zip from control node to VM2
  copy:
    src: "{{ playbook_dir }}/tmp/elasticsearch-ssl-http.zip"
    dest: /tmp/elasticsearch-ssl-http.zip
    mode: '0644'
  when: inventory_hostname == 'vm2'

# 5. Unzip elasticsearch-ssl-http.zip on both VM1 and VM2
- name: Unzip elasticsearch-ssl-http.zip
  unarchive:
    src: /tmp/elasticsearch-ssl-http.zip
    dest: /tmp/
    remote_src: true

# 6. Copy http.p12 to /etc/elasticsearch on both nodes
- name: Copy http.p12 to /etc/elasticsearch
  copy:
    src: /tmp/elasticsearch/http.p12
    dest: /etc/elasticsearch/http.p12
    remote_src: true
    mode: '0644'

# 7. Update elasticsearch.yml to enable HTTP SSL
- name: Enable xpack.security.http.ssl.enabled and set keystore path
  lineinfile:
    path: /etc/elasticsearch/elasticsearch.yml
    regexp: '^xpack\.security\.http\.ssl\.enabled:'
    line: 'xpack.security.http.ssl.enabled: true'
  notify: Restart Elasticsearch

- name: Add keystore path to elasticsearch.yml
  lineinfile:
    path: /etc/elasticsearch/elasticsearch.yml
    line: 'xpack.security.http.ssl.keystore.path: http.p12'
    insertafter: EOF

# 8. Write an empty password in keystore
- name: Add empty password to xpack.security.http.ssl.keystore.secure_password
  shell: |
    echo "" | /usr/share/elasticsearch/bin/elasticsearch-keystore add xpack.security.http.ssl.keystore.secure_password --stdin --force

# 9. Restart elasticsearch service
- name: Restart Elasticsearch
  service:
    name: elasticsearch
    state: restarted

# 1. Copy the CA cert from /home/ubuntu/kibana to Kibana config dir
- name: Copy elasticsearch-ca.pem to Kibana config directory
  copy:
    src: //tmp/kibana/elasticsearch-ca.pem
    dest: "{{ kbn_path_config }}/elasticsearch-ca.pem"
    owner: kibana
    group: kibana
    mode: '0644'
    remote_src: yes
  when: inventory_hostname == 'vm2'

# 2. Ensure elasticsearch.ssl.certificateAuthorities is set in kibana.yml
- name: Set CA path in kibana.yml
  lineinfile:
    path: "{{ kbn_path_config }}/kibana.yml"
    regexp: '^elasticsearch\.ssl\.certificateAuthorities:'
    line: "elasticsearch.ssl.certificateAuthorities: {{ kbn_path_config }}elasticsearch-ca.pem"
    create: yes
  when: inventory_hostname == 'vm2'

# 3. Ensure Elasticsearch hosts is set in kibana.yml
- name: Set Elasticsearch hosts in kibana.yml
  lineinfile:
    path: "{{ kbn_path_config }}/kibana.yml"
    regexp: '^elasticsearch\.hosts:'
    line: "elasticsearch.hosts: https://{{ hostvars['vm1'].ansible_host }}:9200"
    create: yes
  when: inventory_hostname == 'vm2'

# 4. Restart Kibana
- name: Restart Kibana service
  service:
    name: kibana
    state: restarted
  when: inventory_hostname == 'vm2'



- name: Check if CSR bundle already exists
  stat:
    path: /usr/share/elasticsearch/csr-bundle.zip
  register: csr_bundle_exists
  when: inventory_hostname == 'vm1'

- name: Generate CSR and private key for Kibana
  shell: |
    ./bin/elasticsearch-certutil csr -name kibana-server --out /usr/share/elasticsearch/csr-bundle.zip
  args:
    chdir: /usr/share/elasticsearch
  when:
    - inventory_hostname == 'vm1'
    - not csr_bundle_exists.stat.exists


# Unzip the CSR bundle to get CSR and key
- name: Unzip csr-bundle.zip for Kibana
  unarchive:
    src: /usr/share/elasticsearch/csr-bundle.zip
    dest: /usr/share/elasticsearch/
    remote_src: yes
  when: inventory_hostname == 'vm1'

- name: Check if Kibana certificate bundle already exists
  stat:
    path: /usr/share/elasticsearch/certificate-bundle.zip
  register: kibana_cert_bundle
  when: inventory_hostname == 'vm1'

# Sign the Kibana CSR with the CA
- name: Sign Kibana CSR with CA
  shell: |
    ./bin/elasticsearch-certutil cert --pem \
    --ca /tmp/es_certs/elastic-stack-ca.p12 \
    --ca-pass "" \
    -name kibana-server \
    --out /usr/share/elasticsearch/certificate-bundle.zip
  args:
    chdir: /usr/share/elasticsearch
  when:
    - inventory_hostname == 'vm1'
    - not kibana_cert_bundle.stat.exists


# Unzip signed certificate bundle
- name: Unzip signed certificate bundle
  unarchive:
    src: /usr/share/elasticsearch/certificate-bundle.zip
    dest: /usr/share/elasticsearch/kibana-server
    remote_src: yes
  when: inventory_hostname == 'vm1'


# 1. Fetch both files from VM1 to control node
- name: Fetch Kibana server certs from VM1 to control node
  fetch:
    src: "/usr/share/elasticsearch/kibana-server/kibana-server/{{ item }}"
    dest: "{{ playbook_dir }}/tmp/{{ item }}"
    flat: true
  loop:
    - kibana-server.key
    - kibana-server.crt
  when: inventory_hostname == 'vm1'

# 2. Copy both files from control node to VM2
- name: Copy Kibana server certs from control node to VM2
  copy:
    src: "{{ playbook_dir }}/tmp/{{ item }}"
    dest: "{{ kbn_path_config }}/{{ item }}"
  loop:
    - kibana-server.key
    - kibana-server.crt
  when: inventory_hostname == 'vm2'

# Update Kibana SSL settings in config
- name: Update Kibana SSL settings in kibana.yml
  lineinfile:
    path: "{{ kbn_path_config }}/kibana.yml"
    regexp: "{{ item.regexp }}"
    line: "{{ item.line }}"
    create: yes
  loop:
    - { regexp: '^server\.ssl\.enabled:', line: 'server.ssl.enabled: true' }
    - { regexp: '^server\.ssl\.certificate:', line: 'server.ssl.certificate: {{ kbn_path_config }}kibana-server.crt' }
    - { regexp: '^server\.ssl\.key:', line: 'server.ssl.key: {{ kbn_path_config }}kibana-server.key' }
  when: inventory_hostname == 'vm2'

# Restart Kibana
- name: Restart Kibana service
  service:
    name: kibana
    state: restarted
  when: inventory_hostname == 'vm2'
